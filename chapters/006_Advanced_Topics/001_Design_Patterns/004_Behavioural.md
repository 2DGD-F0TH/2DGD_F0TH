Behavioural Design Patterns
---------------------------

Behavioural patterns is a category of design patterns that deals with communication between objects. This is done by identifying common communication patterns between such objects and abstracting it.

### Command Pattern

It may be necessary, during our software development, to abstract our functions into something that can be assigned and treated as an object.

Many programming languages now feature functions as "first class citizens", allowing to treat functions as objects: assigning functions to variables, calling functions, lambdas, inline functions, functors, function pointers...

The command pattern allows us to abstract a function (or any executable line of code) into its own object that can be handled as such, allowing us to package a request into its own object for later use.

This pattern can be useful to code GUIs, making actions in our games that can be undone, macros, replays and much more.

![UML diagram for the Command Pattern](./images/design_patterns/command.svg){width=50%}

```{src='design_patterns/command' caption='Example code for the Command Pattern'}
```

------------------    ------------------------------------------------------------------------------
**Pattern Name**      Command

**When to Use it**    In all situations where you want to avoid coupling an invoker with a single request or when you want to configure an invoker to perform a request at runtime.

**Advantages**        Allows for encapsulation, less coupling, more flexibility and customization at runtime.

**Disadvantages**     Late binding and objects may introduce some overhead.

------------------------------------------------------------------------------------------------

Table: Summary table for the Command Pattern

### Observer Pattern {#ObserverPattern}

The observer pattern is used to implement custom event handling systems, where an object automatically reacts to events generated by another object.

There are 2 main objects used in an observer pattern:

- **The Subject**: sometimes called "Observed Object"
- **The observer**: sometimes called "Dependent Object"

The subject is the creator of a "stream of events" that is consumed by the observer objects.

The subject implements in its structure a list of observers that will be notified when a change occurs, as well as methods to register (add) a new observer as well as to unregister (remove) an existing observer, while the observers will implement a method that will be called by the subject, so that the observers can be notified of such change.

Here we can see an UML diagram of the observer pattern:

![The UML diagram of the observer pattern](./images/design_patterns/observer.svg){width=60%}

Here we can see the Observer abstract class (it can be an interface), a concrete subject and two Concrete Observers that implement what required by the Observer.

Here we can see an implementation of the observer pattern:

```{src='design_patterns/observer' caption='Code for an observer pattern'}
```

If needed, you can pass information between the subject and the observers just by calling each `update()` method with the necessary arguments.

------------------    ------------------------------------------------------------------------------
**Pattern Name**      Observer

**When to Use it**    Event Handling systems, making objects react to other objects' actions

**Advantages**        Decoupling, added flexibility, more performing than if statements for conditions that happen rarely.

**Disadvantages**     Can be a bit hard to set up, makes the architecture more complex, if un-registration is not done well there could be serious memory leaks (even in garbage-collected languages).

------------------------------------------------------------------------------------------------

Table: Summary table for the Observer Pattern

### Strategy

In some situations it may be necessary to select a single algorithm to use, from a family of algorithms, and that decision must happen at runtime.

In this case, the *strategy pattern* (also known as the "policy pattern"), allows the code to receive runtime instructions over what algorithm to execute. This allows for the algorithm to vary independently from the client that makes use of such algorithm.

![The UML diagram of the strategy pattern](./images/design_patterns/strategy.svg){width=60%}

```{src='design_patterns/strategy' caption='Code for a strategy pattern'}
```

------------------    ------------------------------------------------------------------------------
**Pattern Name**      Strategy

**When to Use it**    Every time you need to decide which algorithm to execute at runtime.

**Advantages**        Decoupling, added flexibility.

**Disadvantages**     Can cause proliferation of similarly-looking concrete strategies, late binding on functions and the object oriented nature of the pattern could create some overhead.

------------------------------------------------------------------------------------------------

Table: Summary table for the Strategy Pattern

### Chain of Responsibility

Sometimes we have the necessity of handling conditionals that are themselves connected to runtime conditions. This is where the *chain of responsibility pattern* comes into play, being essentially an object-oriented version of an `if ... else if ... else` statement.

![UML Diagram of the Chain of Responsibility Pattern](./images/design_patterns/chain_of_responsibility.svg){width=50%}

As can be seen from the diagram, the sender is not directly connected to the receiver, but instead it's connected to a "Handler" interface, making them independent.

As with a chain of responsibility in a company relays a task to "higher ups" if the task cannot be handled, the chain of responsibility pattern involves each received reviewing the request and if possible, process it, if not possible, relay it to the next receiver in the chain.

```{src='design_patterns/chain_of_responsibility' caption='Code for a chain of responsibility pattern'}
```

------------------    ------------------------------------------------------------------------------
**Pattern Name**      Chain of Responsibility

**When to Use it**    When you need to implement flexible if...else if...else statements that change on runtime. When you want to decouple a sender from a receiver.

**Advantages**        Decoupling, added flexibility.

**Disadvantages**     Some overhead is added by the objects and late binding, could lead to proliferation of similar-looking handlers/receivers.

------------------------------------------------------------------------------------------------

Table: Summary table for the Chain of Responsibility Pattern

### Visitor

{{placeholder}}

<!-- TODO: Visitor Design pattern + code -->
